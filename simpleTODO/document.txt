features:
this is a multi-user web app
users can sign up a new account
login to their account
logout from their account
delete their account permanently 
edit their account information
create a new tasks
see their tasks
edit their tasks
delete their tasks
send message to the sites' admin
admin can see Total users, Total messages sent by users, Total tasks created in the database.
admin can see messages sent by the users
can promote / demote users
can temporarly suspend / unsuspend a user
can permanently delete a user's account

+++++++++++++++++++++++++++++++++++++++

Database's schema:
users table has these columns:
id           int
userId       varchar(64)
username     varchar(30)
password     varchar(64)
firstName    varchar(20)
lastName     varchar(20)
email        varchar(40)
phoneNumber  varchar(10)
rule         varchar(5)
suspended    varchar(3)

tasks table has these columns:
id           int 
author       varchar(64)
priority     varchar(6)
category     varchar(20)
title        varchar(30)
description  varchar(70)
status     varchar(10)

messages table has these columns:
id           int 
author       varchar(64)
priority     varchar(6)
category     varchar(20)
title        varchar(30)
description  varchar(70)
status     varchar(10)

sessions table has these columns:
id           int
sessionId    varchar(64)
userId       varchar(64)

+++++++++++++++++++++++++++++++++++++++

Routing:
since the golang treats the URL patter "/" like a catch all.
when user visits any path, the HandleFunc for the "/" will call RoutingHandler.
all the routes will be divided into 3 main categories:
routes relevant to users which start with "/users/"
routes relevant to tasks which start with "/tasks/"
routes relevant to admin which start with "/admin/"
the routing will be decided by if else conditions and to prevent any unnecessary conditoin checking.
first the url's category will be determined by checking its prefix;
and then check the paths relevant to that category.

+++++++++++++++++++++++++++++++++++++++

users sign up process:
//signup page
when user visits "/users/signup" path the SignupPageHander will be called.
in SignupPageHander it first check for a cookie named "session_id" to determine if a logged user is visiting this path or not.
if there is a "session_id" cookie already, the user will be redirected to the "/users/home" path to their home page.
if there is no "sessoin_id" cookie,
then a variable named csrft will be initialized with random string generated by GenerateUUID function.
then a cookie with the name of "signupcsrft" and the value of csrft variable will be set on the browser.
then the signup page html will be parsed and rendered with csrft as a form's hidden input.
in the signup page there is a form which takes:
username, password, firstName, lastName, email and phone number from user.
the action attribute for this form is "/users/signupprocess".
so when the user clicks on submit button the form will be submitted to "/users/signupprocess" via POST method.

//signup process
after the from was submitted to "/users/signupprocess" the SignupProcessHandler will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is a "session_id" cookie already, the user will be redirected to the "/users/home" path and the "signupcsrft" cookie will be deleted from the browser.
if there is no "sessoin_id" cookie:
if will check for csrft token named "signupcsrft" coookie, 
if there is no "signupcsrft" cookie user will be redirected to "/users/signup" path and the "signupcsrft" cookie will set to be deleted from the browser anyway.
if there is a "signupcsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not
if they are not the same user will be redirected to "/users/signup" path and the "signupcsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/users/signup" path and the "signupcsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the username, password, firstname, lastname, email, phone number value and validate them.
if any of the forms input provided by the user is not valid, user will be redirected to "users/signup" path to reenter those values and the "signupcsrft" cookie will be deleted from the browser.
if the user's inputs are valid it will hash the password to be stored in the database in a hashed form not the original form.
and a variable named userId and a variable named sessionId will be initialized by random string generated by GenerateUUID function.
then a user record will be created with:
id => auto incremented
userId => generated by GenerateUUID
username => provided by user
password => hashed value of what user provided
firstName => provided by user
lastName => provided by user
email => provided by user
phoneNumber => provided by user
rule => by default as "user"
suspended => by default as "no"
also a new session record will be created with:
sessionId => generated by GenerateUUID function
userId => generated by GenerateUUID function
after everything went through a new cookie named "session_id" will be set on the browser to remember the logged user.
and the "signupcsrft" cookie will be deleted from the browser.
and the user will be redirected to "/users/home" path to their home page.

+++++++++++++++++++++++++++++++++++++++

users login process:
//login page
when user visits "/users/login" path the LoginPageHandler will be called.
in LoginPageHandler it first check for a cookie named "session_id" to determine if a logged user is visiting this path or not.
if there is a "session_id" cookie already, the user will be redirected to the "/users/home" path to their home page.
if there is no "sessoin_id" cookie:
then a variable named csrft will be initialized with random string generated by GenerateUUID function.
then a cookie with the name of logincsrft and the value of csrft variable will be set on the browser.
then the login page html will be parsed and rendered with csrft as a form's hidden input.
in the login page there is a form which takes:
username, password from user.
the action attribute for this form is "/users/loginprocess".
so when the user clicks on submit button the form will be submitted to to "/users/loginprocess" via POST method.

//login process
after the from was submitted to "/users/loginprocess" the LoginProcessHandler will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is a "session_id" cookie already, the user will be redirected to the "/users/home" path and the "logincsrft" cookie will be deleted from the browser.
if there is no "sessoin_id" cookie:
it will check for csrft token named "logincsrft" coookie, 
if there is no "logincsrft" cookie user will be redirected to "/users/login" path and the "logincsrft" cookie will set to be deleted from the browser anyway.
if there is a "logincsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not
if they are not the same user will be redirected to "/users/login" path and the "logincsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/users/login" path and the "logincsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the username, password value and validate them.
if any of the forms input provided by the user is not valid, user will be redirected to "/users/login" path to reenter those values and the "logincsrft" cookie will be deleted from the browser.
if input forms value are valid, it will hash the password to validate the user's existense.
the ValidateUser will take the username and the password and send a query to get a user with that username and that password.
if a user comes back that means the credentials were correct.
if the credentials are not correct user will be redirected to "/users/login" path and the "logincsrft" will be deleted from the browser.
if the credentials are correct a variable named "session_id" will be set to the browser to remember the logged user.
then it will get the user's info.
then a new session record will be created with:
sessionId => generated by GenerateUUID
userId => the existing user's userId
then the "logincsrft" cookie will be deleted from the browser and the user will be redirect to "/users/home" path to their home page..

+++++++++++++++++++++++++++++++++++++++

users Home Page:
//Home page
the user's home page contains three main part.
1- a series of buttons for logging out, editting account's info, sending a message to the site's admin.
2- a form which users can create new task.
3- already existing user's task will be shown.
when user visits "/users/home" path the HomePageHandler will be called.
in HomePageHandler it first check for a cookie named "session_id" to determine if a logged user is visiting this path or not.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie a variable named csrft will be initialized by a random string generated by GenerateUUID function.
then a cookie with the name of "createtaskcsrft" and the value of csrft variable will be set on the browser.
according to the value of the "session_id" user's username, id and userId will be stored in 3 different variables.
then the user's task, which are the task with author value of the logged user's userId will fetched from database and be rendered and shown in the home page.
also the csrft will be rendered as a hidden form input.
in the form section of the home page which is for creating a task gets:
task's title, task's description, task's category and task's priority.
the action attribute for this form is "/tasks/createtaskprocess".
so when the user clicks on submit button the form will be submitted to to "/tasks/createtaskprocess" via POST method.

+++++++++++++++++++++++++++++++++++++++

user editing:
//user editting page
when users home page is rendered a button named edit account will be rendered too, 
which is a link to "/users/editaccount/V" where V is the ID of that user.
for example if a user has the id of 4 the edit account button will be a link to "/users/editaccount/4"
now when user clicks on that button it will go to "/users/edituser/4" and then UpdateUserPageHandler will be called.
first it will look for a cookie named "session_id" to determine if a logged user is visiting this path.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie a variable named csrft will be initialized by a random string generated by GenerateUUID function.
then a cookie with the name of "updateusercsrft" and the value of csrft variable will be set on the browser.
then a new variable named "usersid" will be initialized which is the the id of the logged user.
then a new variable named "usersIdurl" will be initialized which is the id trimmed out of the url.
it will check if the "usersid" which is the id of the logged user is the same as 
"usersIdurl" which is the id of the user came in the url.
if they are not the same that means an unauthorized user is trying to access another user's info.
so it will redirect them to their home page in "/users/home"
if the "userid" and "usersIdurl" the same that means the user is authorized and trying to edit their own account.
it will get that user's info then the edit user page html will be parsed and rendered with current value of that user's info and also csrft as a form's hidden input.
the action attribute for this form is "/users/edituserprocessor".
so when the user clicks on submit button the form will be submitted to to "/users/edituserprocessor" via POST method.

//edit user process
after the from was submitted to "/users/edituserprocessor" the UpdateUserProcessor will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie a variable named csrft will be initialized by a random string generated by GenerateUUID function.
it will check for csrft token named "updateusercsrft" coookie and gets the userId of the logged user into a varaible named "loggedUser"
if there is no "updateusercsrft" cookie user will be redirected to "/users/home" path and the "updateusercsrft" cookie will set to be deleted from the browser anyway.
if there is a "updateusercsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not
if they are not the same user will be redirected to "/users/home" path and the "updateusercsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/users/home" path and the "updateusercsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the username, current password, new password, first name, last name, email, phone number value and validate them.
if any of the forms input provided by the user is not valid, user will be redirected to "users/home" path to reenter those values and the "updateusercsrft" cookie will be deleted from the browser.
then it will try to get the user with the entered current password to see if the user entered their password correctly or not.
if they entered the wrong password they will be redirect to the "/users/home" path.
if they entered the correct password it will check if the "newpassword" is empty or not.
if it's empty that means the user didn't want to change their password so it will get the provided values and update the user.
and the "updateusercsrft" cookie will be deleted from the browser and user will be redirected to "/users/home" path.
if it's not empty that means the user want to change their password, so it will first validate the newpassword and update the user with the password (hashed value)
and the "updateusercsrft" cookie will be deleted from the browser and user will be redirected to "/users/home" path.

+++++++++++++++++++++++++++++++++++++++

users logout:
in users home page there is a button named logout.
this button is a link to "/users/logout"
when user visits this path the "session_id" and "createtaskcsrft" cookie will be deleted from the browser and
user will be redirect to "/users/login"

+++++++++++++++++++++++++++++++++++++++

users sending message to the admin:
//user sending message to the admin page
when user's home page is rendered a button named send message will be rendered too, 
this button is a link to "/users/messages"
when user visits "/users/messages" UserMessagePageHandler will be called.
first it will look for a cookie named "session_id" to determine if a logged user is visiting this path.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie a variable named csrft will be initialized by a random string generated by GenerateUUID function.
then a cookie with the name of "createmessagecsrft" and the value of csrft variable will be set on the browser.
there is a form in that page which gets input from users for their message to admin which are:
Message's title, Message's description, Message's category, Message's priority.
and also csrft as a form's hidden input.
the action attribute for this form is "/users/createmessageprocessor".
so when the user clicks on submit button the form will be submitted to to "/users/createmessageprocessor" via POST method.

//user sending message to the admin processor
when users filled the information needed and hit the send message button.
the form will be submitted to "/users/createmessageprocessor" and when it goes to "/users/createmessageprocessor" the CreateUserMessageProcessor will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie :
it will check for csrft token named "createmessagecsrft" coookie, 
if there is no "createmessagecsrft" cookie user will be redirected to "/users/messages" path and the "createmessagecsrft" cookie will set to be deleted from the browser anyway.
if there is a "createmessagecsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not.
if they are not the same user will be redirected to "/users/messages" path and the "createmessagecsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/users/messages" path and the "createmessagecsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the username of the user according to the "session_id" to be used as the author of that message.
then it will get the title, description, category and priority from the form.
if any of the forms input provided by the user is not valid, user will be redirected to "user/messages" path to reenter those values and the "createmessagecsrft" cookie will be deleted from the browser.
if input forms values are valid:
then a new message record will be created with:
author => user's username sccording to the session_id value
priority => provided by user
category => provided by user
title => provided by user
description => provided by user
status => by default as "unfinished"
then the "createmessagecsrft" cookie will be deleted from the browser and the user will be redirect to "/users/home" path to their home page.

+++++++++++++++++++++++++++++++++++++++
user creating a task:
//creating task page:
third part of three main part of user's home page is a form for adding a task.
a variable named csrft will be initialized by a random string generated by GenerateUUID function.
then a cookie with the name of "createtaskcsrft" and the value of csrft variable will be set on the browser.
there is a form in home page which gets input from users for their tasks which are:
Tasks's title, Tasks's description, Tasks's category, Tasks's priority.
and also csrft as a form's hidden input.
the action attribute for this form is "/tasks/createtaskprocess".
so when the user clicks on submit button the form will be submitted to to "/tasks/createtaskprocess" via POST method.

//creating task process:
when users filled the information needed and hit the send message button.
the form will be submitted to "/tasks/createtaskprocess" and when it goes to "/tasks/createtaskprocess" the CreateTaskProcessor will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie:
it will check for csrft token named "createtaskcsrft" coookie, 
if there is no "createtaskcsrft" cookie user will be redirected to "/users/home" path and the "createtaskcsrft" cookie will set to be deleted from the browser anyway.
if there is a "createtaskcsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not.
if they are not the same user will be redirected to "/users/home" path and the "createtaskcsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/users/home" path and the "createtaskcsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the userId of the user according to the "session_id" to be used as the author of that task.
then it will get the title, description, category and priority from the form.
if any of the forms input provided by the user is not valid, user will be redirected to "user/home" path to reenter those values and the "createtaskcsrft" cookie will be deleted from the browser.
if input forms values are valid:
then a new task record will be created with:
author => user's username sccording to the session_id value
priority => provided by user
category => provided by user
title => provided by user
description => provided by user
status => by default as "unfinished"
then the "createtaskcsrft" cookie will be deleted from the browser and the user will be redirect to "/users/home" path to their home page.

+++++++++++++++++++++++++++++++++++++++

task editing:
//task editting page
when tasks are rendered in home page, each task will have two buttons for editting and deleting that task.
edit button is a link to this address:
"/tasks/edittask/V" where V is the ID of that task.
for example if a task has the id of 4 the edit button will be a link to "/tasks/edittask/4"
now when user clicks on that button it will go to "/tasks/edittask/4" UpdateTaskPageHandler will be called.
first it will look for a cookie named "session_id" to determine if a logged user is visiting this path.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie a variable named csrft will be initialized by a random string generated by GenerateUUID function.
then a cookie with the name of "updatetaskcsrft" and the value of csrft variable will be set on the browser.
then a new variable named "usersid" will be initialized which is the the id of the logged user.
then a new variable named "taskId" will be initialized which is the id of that task is trimmed out of url.
it will try to get the task that has the id of "taskId" and the "userId" as its author to make sure the logged user is actually the author of that task.
if nothing came back, that means the logged user is trying to access a task that is not for that user.
if a task came back it will get that task and the edit task page html will be parsed and rendered with the current value of that task's info and also csrft as a form's hidden input.
the action attribute for this form is "/tasks/edittaskprocessor".
so when the user clicks on submit button the form will be submitted to to "/tasks/edittaskprocessor" via POST method.

//edit task process
after the from was submitted to "/tasks/edittaskprocessor" the UpdateTaskProcessor will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id" cookie a variable named csrft will be initialized by a random string generated by GenerateUUID function.
it will check for csrft token named "updatetaskcsrft" coookie and gets the userId of the logged user into a varaible named "loggedUser"
if there is no "updatetaskcsrft" cookie user will be redirected to "/users/home" path and the "updatetaskcsrft" cookie will set to be deleted from the browser anyway.
if there is a "updatetaskcsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not
if they are not the same user will be redirected to "/users/home" path and the "updatetaskcsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/users/home" path and the "updatetaskcsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the title, description, category, priority value and validate them.
if any of the forms input provided by the user is not valid, user will be redirected to "/users/home" path to reenter those values and the "updateusercsrft" cookie will be deleted from the browser.
then it will try to get the task with the that id and loggedUser usersId as the author.
if a task came back that means the loggedUser is the author of that task with that id.
and the task will be updated with those values and "updatetaskcsrft" will be deleted from the browser and the user will be redirected to "/users/home" to their home page.
if nothing came back that means the loggedUse is not authorized to do this and will be redireted to "/users/home" and "updatetaskcsrft" will be deleted from the browser.

+++++++++++++++++++++++++++++++++++++++

tasks deleting:
when tasks are rendered in home page, each task will have two buttons for editting and deleting that task.
delete button is a link to this address:
"/tasks/deletetask/V" where v is the ID of that task.
for example if a task has the id of 4 the delete button will be a link to "/tasks/deletetask/4"
now when user clicks on that button it will go to /tasks/deletetask/4 and a new variable named taskID will be created with the value of 4.
first it will look for a cookie named "session_id" to determine if a logged user is visiting this path.
if there is no "session_id" cookie that means the user is not logged in and is not authorized to visit this path so it will redirect the user to "/users/login" path.
if there is a "session_id":
it will store the userId of the logged user into a varaible named "loggedUser"
then the taskId will be trimmed out of the url and be stored in a variable named taskId.
then it will try to get the task with that id and loggedUser as the author to make sure the actual author of this task is trying to delete this task.
if a task comes back that means the logged user is authorized to delete this and it will delete this task and user will be redirected to the "/users/home" to their home page.

+++++++++++++++++++++++++++++++++++++++

Admin login process:
//login page
when user visits "/admin/login" path the AdminLoginPageHandler will be called.
in AdminLoginPageHandler it first check for a cookie named "session_id" to determine if a logged user is visiting this path or not.
if there is a "session_id" cookie already, the user will be redirected to the "/admin/home" path to their Admin home page.
if there is no "sessoin_id" cookie:
then a variable named csrft will be initialized with random string generated by GenerateUUID function.
then a cookie with the name of adminlogincsrft and the value of csrft variable will be set on the browser.
then the login page html will be parsed and rendered with csrft as a form's hidden input.
in the login page there is a form which takes:
username, password from user.
the action attribute for this form is "/admin/loginprocess".
so when the user clicks on submit button the form will be submitted to to "/admin/loginprocess" via POST method.

//login process
after the from was submitted to "/admin/loginprocess" the AdminLoginProcessHandler will be called.
first it will check for a cookie named "session_id" to determine if a logged users is sending the request or not.
if there is a "session_id" cookie already, the user will be redirected to the "/admin/home" path and the "adminlogincsrft" cookie will be deleted from the browser.
if there is no "sessoin_id" cookie:
it will check for csrft token named "adminlogincsrft" coookie, 
if there is no "adminlogincsrft" cookie user will be redirected to "/admin/login" path and the "adminlogincsrft" cookie will set to be deleted from the browser anyway.
if there is a "adminlogincsrft" it will parse the form and get the csrft hidden input values to check if they are the same or not
if they are not the same user will be redirected to "/admin/login" path and the "adminlogincsrft" cookie will be deleted from the browser.
if they are the same it will check to see of the request method is POST or not.
if the request method is not POST user will be redirected to "/admin/login" path and the "adminlogincsrft" cookie will be deleted from the browser.
if the request method is POST, it will get the username, password value and validate them.
if any of the forms input provided by the user is not valid, user will be redirected to "/admin/login" path to reenter those values and the "adminlogincsrft" cookie will be deleted from the browser.
if input forms value are valid, it will hash the password to validate the user's existense.
the ValidateUser will take the username and the password and send a query to get a user with that username and that password and rule value of "admin".
if a user comes back that means the credentials were correct.
if the credentials are not correct user will be redirected to "/admin/login" path and the "adminlogincsrft" will be deleted from the browser.
if the credentials are correct a variable named "session_id" will be set to the browser to remember the logged user.
then it will get the user's info.
then a new session record will be created with:
sessionId => generated by GenerateUUID
userId => the existing user's userId
then the "adminlogincsrft" cookie will be deleted from the browser and the user will be redirect to "/users/home" path to their home page..

+++++++++++++++++++++++++++++++++++++++

admin Home Page:
when user visits the "/admin/home" path the AdminHomePageHandler will be called.
first it will check for a cookie named "session_id" to determine if a logged user is visiting this path or not.
if there is no "session_id" user will be redirected to the "/users/login" path.
if there is a "session_id" that means a user is logged in, it will get that user's rule based on the session_id.
if their rule is not "admin" they will be redirected to "/users/home" to their home page.
if their rule is "admin" it will get Totalusers, Totaltasks and Totalmessages
then the admin home page will be rendered with those informations and be shown to the admin.

+++++++++++++++++++++++++++++++++++++++

admin visiting messages send by the users to the admin:
in admin home page there is a button named show messages.
this button is a link to "/admin/messages"
when admin visits "/admin/messages" AdminMessagesPageHandler will be called.
it will get all messages from the database and it will parse and show the admin message page.
in that page it will show all the messages sent by used and with informations like:
Author, title, Description, Category, Priority, completed.

+++++++++++++++++++++++++++++++++++++++

user input validations:

user's info input validation:

username -> can't be empty.
	 -> 5 <= username length <= 30
	 -> can be only be alpha numeric.

password -> can't be empty.
	 -> 5 < password length
	 -> must be alpha numeric and contain at least a symbol.
	
firstName -> can't be empty.
	  -> 3 <= first name length <= 20
	  -> can only be alphabetic.

lastName  -> can't be empty.
	  -> 3 <= last name length <= 20
	  -> can only be alphabetic.

email -> can't be empty.
      -> email length >= 40
      -> must follow email patter.

phoneNumber -> can't be empty
	    -> phone number length <= 10
	    -> only can be numeric

---------------------------------------

tasks's info input validation:

priorty -> can't be empty.
	 -> 3 <= priority length <= 6
	 -> can be only be alphabetic.

category -> can't be empty.
	 -> category length <= 20
	 -> can be only be alphabetic.
	
title -> can't be empty.
	  -> title <= 30
	  -> can be any string

description  -> can't be empty.
	  -> description <= 70
	  -> can be any string

status -> can't be empty
       -> 8 <= status length <= 10
       -> can be only be alphabetic.

+++++++++++++++++++++++++++++++++++++++
